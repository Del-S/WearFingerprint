\chapter{Application design and implementation}\label{sec:ApplicationDesingAndImplementation}
This chapter describes all important information about created application. First is hardware and software used for developing and testing of the application. Second is structure and description of core parts used in the application. 

\begin{figure}[H]
	\begin{centering}
		\includegraphics[width=0.6\textwidth]{img/server_architecture}
		\par\end{centering}
	\caption{Application architecture (based on \cite{IILUBLEB})}
	\label{fig057}
\end{figure}

\fref{fig057} shows basic devices and technologies used in this application. There are three main part of this implementation, mobile, wear and server application. Mobile and wear parts implement scanning for radio signals and are written in Java language for Android system. Server is also programmed in Java to keep implementations close to each other and make future adjustments easier. Main goal of the server is to store scanned data.

\section{Hardware}\label{sec:Hardware}
There are multiple hardware devices used in this application. All of them can be seen on \fref{fig057}, where first and the most obvious are smartphone and smartwatch. These devices scan radio signals from WiFi access-points and BLE beacons that are placed in the indoor environment. And a final hardware part is a server holding scanned data from all devices.

\subsection{Smartphone and Smartwatch}\label{subsec:SmartphoneAndSmartWatch}
Both smart devices must support scanning of Bluetooth Low Energy beacons that can be done with Bluetooth 4.0 and higher. Secondary requirements are Wi-Fi, GSM and LTE modules to support more data types than just BLE beacons.

\subsubsection{Phone}\label{subsubsec:Phone}
Main part of the application is developed and tested on Redmi Note 4 from Chinese company Xiaomi. It is running customized version of Android 6.0 called MIUI. Even thought system was customized, in core it is still Android so there are no problems in that regard \cite{XRN4LTE}. This phone has Bluetooth 4.1 with LE support so main requirement for the hardware is met, with all the secondary requirements also met with Wi-Fi 802.11 a/b/g/n, GSM, and LTE support like most modern smartphones would \cite{XRN4FPS}.

One interesting thing about Xioami smartphones is their locked bootloader. It prevents users from any manual updates but most importantly from factory reset. To unlock it owner has to create an account in Xiaomi website and put a request to unlock bootloader. This request is usually processed within two weeks period and there is no actual guarantee of it being approved. After evaluation process is complete user is notified via sms about the result of such request.

\subsubsection{Smartwatch}\label{subsubsec:Smartwatch}
First goal of this thesis was to select smartwatches running on Android Wear 2.0 technology. This iteration is quite new currently, which makes it harder to select proper wear device since there are not so many options. During selection process there were around twenty of watches with this system and only five of them were selected to closer inspection based on few articles \cite{BAWW, BAWW18, BAWW17}.

\begin{table}[h]
	\scriptsize
	\begin{center}
		\begin{tabular}{| m{3cm} | c | c | l |}
			\hline
			Watch & BLE / Wi-Fi & Czech Republic & Problems \\ \hline
			LG W280 Sport & Yes / Yes & No & \begin{tabular}[c]{@{}l@{}} Battery life is one day or less. \\ Too big in size. \end{tabular} \\ \hline
			LG W270 Titanium Style & Yes / Yes & Yes & Battery life is one day or less. \\ \hline
			Huawei Watch 2 & Yes / Yes & Yes & \begin{tabular}[c]{@{}l@{}} First update can take a long time. \\ Slight Bluetooth pairing issues. \end{tabular} \\ \hline
			Polar M600 & Yes / Yes & Yes & \begin{tabular}[c]{@{}l@{}} Polar support complains. \\ Phone synchronization issues. \\ GPS location malfunctions. \end{tabular} \\ \hline
			ASUS ZenWatch 3 & Yes / Yes & No &  \begin{tabular}[c]{@{}l@{}} Strap breaks fast. \\ AW 2.0 update can break the watch. \\ ASUS support complains. \end{tabular} \\ \hline
		\end{tabular}
		\caption{Smartwatch comparison (sources: \cite{LGWSP, LGWST, HW2, PM600, AZW3})}
		\label{tab2}
	\end{center}
\end{table}

Only one smartwatch could be selected out of five displayed in \tref{tab2}. Firstly, wear device had to support BLE and Wi-Fi which all have. Secondly, it must have been sold in Czech Republic (CR) since it makes shipping and warranty easier. Only three of five devices were sold in Czech Republic at that time so others were taken out of the consideration. Final decision was made based on extensive research of customer reviews in shopping sites such as Amazon, CZC, Heureka, Alza, wear official websites \cite{LGWSP, LGWST, HW2, PM600, AZW3} and other tech sites \cite{BAWW, BAWW18, BAWW17}. Finally, selected device was Huawei Watch 2 since there were not too many problems in reviews and other requirements were met.

Initial setup of the wear device was composed of two main parts. First, update wear system which took about one to two hours. Second task was to setup the watch and copy Google account, this is where some problem were discovered. Copying of accounts from Redmi Note 4 to the watch never completed. To fix this problem another smartphone (Huawei Y5 II) was used to copy the account, it was already mentioned that only single device can be connected to smartwatch and connecting to a new one requires factory reset removing all the data. It was needed to pair wear with phone without factory reset which was handled via Android Debug Bridge following this \cite{HtPAWW} article.

Since Google wants to focus also on iOS devices technology Android Wear 2.0 was rebranded to Wear Os by Google to remove confusion in the future \cite{AWITFNM}. This updated was forced on wear devices, updating it to the newest Android version which forced some changes in the development of this solution. First, implementation bug in scanning library was introduced and had to be fixed. Second and bigger problem was inability to deploy new version of the application from Android Studio to the watch. This, for some reason, effects the main computer used to develop this application and it was fixed by using another computer.

\subsection{Radio signal devices}\label{subsec:RSD}
As hardware devices are used BLE beacons, WiFi access-points and Cellular towers. Only first two types of these devices can be placed inside a building and are most commonly used in indoor localization. Signal from cellular towers is only a complimentary data that does not have to be used and cannot be influenced since they are placed by telecommunication companies.

\subsubsection{BLE beacons}\label{subsec:BLEBeacons}
Beacons are small devices that can be easily placed in almost any environment. Only thing they do is send an information packets using Bluetooth and nothing else. They are commonly used in museums, airports and as of late in indoor localization \cite{10TABB}. Beacons have their own battery powering them which can last around a year or two without charging because of the new Bluetooth Low Energy (BLE) standard. This technology drastically reduces power consumption and introduces new configuration
options regarding the advertising interval and the transmitter output power \cite{IPSBOBLE}. More in depth description of this technology and devices was written by Pavel Kriz et al. \cite{IILUBLEB}.

There are multiple beacon manufacturers with their own quality, signal strength, battery life and other hardware differences. Changes can also be found in software (packet) specifications for beacons, meaning data they send have different format but it does not mean other systems cannot see them. Usually some software changes have to be made to detect such beacons but they are documented and not hard to make. Beacons are also usually platform independent, making them work with multiple platforms such as Android or iOS \cite{IPSBOBLE, 10TABB}. Beacons used in this thesis are from a company called Estimote and they are most commonly used.

\begin{figure}[H]
	\begin{centering}
		\includegraphics[width=0.6\textwidth]{img/estimote_beacon}
		\par\end{centering}
	\caption{Parts of Estimote beacon (source: \cite{RMPFEB})\label{fig:PartsOfEstimoteBeacon}}
	\label{fig10}
\end{figure}

Another important thing to note, Beacons are not connected to the Internet and do not collect any data from devices around them. Meaning all the data have to be processed in another device, most commonly a smartphone, and it also makes Beacon safe to use because there is no need to worry about sensitive data theft \cite{10TABB}.

\subsubsection{WiFi access-points}\label{subsec:WiFi access-points}
WiFi signals are commonly used in indoor localization due to their presence almost anywhere. In this case several WiFi transmitters of the \verb|eduroam| network made by Cisco were used. They are permanently deployed on every floor of a test building and cannot be influenced or changed.

\section{Server}\label{sec:Server}
Implemented application do not necessarily need a server for its core functionality but it is common and faster to run an analysis of the data and other heavy computational work on a different, faster device. Functionality of the server is to serve as a backup of the data and also as a synchronization point to enable other devices to download fingerprints and upload new ones.

The server infrastructure was built in previous years \cite{IILUBLEB} but it was improved for this solution. It uses NoSQL database to save fingerprints. This type of database does not have fixed scheme, making it easy to save all kinds of data. There are many NoSQL databases, around 250 at this time, to choose from. Selected database is called Couchbase, it saves data in JSON files with its own query language similar to SQL. Part of this database can also replicate data between other devices which could be used in the application part. In the end it was deemed too slow and data heavy for usage in the application, creating the need for creation of a middleman API between Android application and Couchbase database.

As \fref{fig057} shows server has three main parts to work with. First, already mentioned is Couchbase database to keep scanned data. Second, sync gateway that can synchronize data between devices, not used in this implementation. Both of these part were already implemented in previous years \cite{IILUBLEB}. Final part is web application working as a REST API to send data between the server and mobile application. 

This API is written in Java based framework called Spring to keep the code similar to Android. It was documented using Swagger and it handles two main HTTP routes: \verb|fingerprints| and  \verb|fingerprints-meta|. Before any tasks are issued, mobile application checks data on the server using \verb|fingerprints-meta| route which returns count of new fingerprints and last time specific device saved fingerprints on the server. With this information the application knows how many fingerprints to upload and download, in this specific order, to ensure data is stored first. To prevent device memory exhaustion and connection timeout both of these tasks have specific limits, download can process 100 of fingerprints while upload only 20. Server can also generate data files for analysis, split by technology, time, origin device and other filters. To simplify this generation it is similar loading all fingerprints, meaning it does not create file but prints the data directly into the connection stream.

One last thing to note in \fref{fig057} is the connection with sync gateway. Even though it is not used in this implementation for synchronization it is used to save fingerprints into the database. When data is saved into Couchbase directly sync gateway will not display them, that is why the upload must go through the gateway. This is to ensure all previous and next solution can use this feature without loosing any important data.

\section{Application Software}\label{sec:ApplicationSoftware}
Software part for smartphone and smartwatch uses Android system which was already described in \hyperref[sec:Android]{Chapter 3}. This section will provide basic information about libraries, technologies and systems used in such applications.

\subsection{AltBeacon Library}\label{subsec:AltBeaconLibrary}
Since Android core does not allow scanning for BLE beacons this feature must be implemented in a library extending system features. There are multiple solutions that can be used to scan for beacons such as Estimote SDK \cite{ESDKfA} which was already used in previous thesis \cite{PMRIL}. To change things up BLE beacons are found via AltBeacon Library \cite{ABL}.

Since there was no open and inter-operable specification for proximity beacons, Radius Networks has created the AltBeacon specification as a proposal to solve this issue. It is an open and free specification for BLE beacons with focus to create an open, competitive market for implementation of these devices \cite{AltB}. Basic configuration of this library can scan for beacons based on this standard and it also supports Eddystone beacons which is Google's open source format. To support already mentioned Estimote beacons this library configuration must be altered to support their detection. Luckily this function can be easily modified to support different kinds of beacons by just one following line of code \cite{ABL, EDDF}.

\begin{lstlisting}[caption=Code to enable all beacon types]
beaconManager.getBeaconParsers().add(
	new BeaconParser().setBeaconLayout("m:2-3=0215,i:4-19,
		i:20-21,i:22-23,p:24-24"));
\end{lstlisting}

This library uses publish-subscribe design pattern, meaning one scan data is send to multiple clients if they listen for them. Using this approach has an advantage of eliminating the need to run a scan per client. Update to Android 8 introduced a bug in this feature making it unable to confirm the registration of client so the scanner has to be reworked thus postponing the data collection and analysis.

\subsection{Database}\label{subsec:Database}
This solution makes use of two different types of databases to store all the Fingerprint data for calculations. First, is SQLite database implemented in Android mobile application to save Fingerprints from smartphone and smartwatch. This database is default implementation and most commonly used in Android applications. Second database type is Couchbase implemented on the server \verb|beacons.uhk.cz| to keep all Fingerprint data in one place and this enable synchronization and data analysis.

\subsubsection{SQLite database}\label{subsec:SQLiteDatabase}
SQL (Structured Query Language) is a standard language for storing, manipulating and retrieving data in databases. It is a type of Relational Database, meaning all data is saved into tables with specified rows and columns \cite{WISQLITE}. These tables usually have set amount of rows with specific names that protect from adding wrong data, for example you cannot add data \verb|Person(name, surname, eye color)| into table \verb|Person(name, surname)| because there is no column named \verb|eye color| in the table.

Structured data is one of the advantages of this database type and it makes calculation faster but usually uses more storage space. Other advantage is that data can be only saved once since they can be connected to each other. It supports complex queries for creating, reading, updating and removing data (CRUD) and better security with user and table management. Some disadvantages of this system can be with complexity and inflexibility of database scheme because it is hard to setup and does not allow other data then is defined in the tables \cite{ERDMS}. Altering schemes in the future can be really complex since there is the need to parse all previous data to the new tables which does not need to have the same scheme as previous ones.

Since SQL with all its features can consume a lot of hardware resources for a smartphone, Android decided to implement lite version of this database. SQLite has the following noticeable features: self-contained, serverless, zero-configuration, transactional \cite{WISQLITE}.

\begin{itemize}
	\item Serverless = does not need second process for the server.
	\item Self-Contained = requires minimal support from operating system.
	\item Zero-configuration = no need for installation or any configuration.
	\item Transactional = data are protected against failed changes (application crashes, power failure, ...).
\end{itemize}

\subsubsection{Couchbase database}\label{subsec:CouchbaseDatabase}
Since SQL based databases can be complex to implement, scale and usually require more data storage space there was a motivation to create so called NoSQL databases. Their most important and significant feature is not having a fixed scheme, that makes them easy to scale and replicate between multiple devices. There are around 225 NoSQL databases at this time and selected Couchbase is one of them \cite{NOSQLDB}.

Couchbase is distributed, document-based database with its own querying language called N1QL. It is a database focused on simple server configuration and easy usage for clients, with built in caching layer and distribution system it does not require any changes in the application. There can be either one server instance of Couchbase or multiple connected to create a database cluster which holds all the data in multiple locations (nodes) \cite{GSWCBS}. This data is saved in JSON file format and usually in readable form without any encryption.

\begin{lstlisting}[caption=JSON format example]
[
	{
		"id":"1",
		"data":{},
		"device":{}
	},
	{
		"id":"2",
		"data":{},
		"device":{}
	}
]
\end{lstlisting}

Since SQL is used for decades and it became standard for working with data in databases, Couchbase embraces this approach and extends it for JSON files, this language is called N1QL. It has all the main features of the SQL with some minor improvements \cite{WINQL}. Currently this language can be used only on the server implementation, meaning Android cannot use this feature. Version for mobile application is called Lite and instead of N1QL so called \verb|views| are used, they are objects containing all the selected data from the documents. Major problem of \verb|views| is being very data heavy which is shown in \hyperref[subsubsec:Comparison]{Comparison} section. That is one of two main points why mobile and wear applications use an SQLite instead of Couchbase. Second point is to differentiate between previous solutions and test data consumption and load speed of SQL database.

\subsubsection{Comparison}\label{subsubsec:Comparison}
Both of these database solutions were tested on Android mobile application to figure out which one is faster and takes less data storage space. As a test 315 fingerprint documents will be loaded and displayed, all of them have more than 500 sub-documents which makes about 150 000 documents. As \tref{tab3} shows SQLite takes less space and is almost three times faster in loading all the documents, that is why it was selected for this project. If Couchbase Lite would have faster query time or supported the use of N1QL it would be preferable solution but it is not at this time.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{| l | c | c |}
			\hline
			Database type & Data size & Loading speed (315 documents) \\ \hline
			SQLite & 15MB & 23 second \\ \hline
			Couchbase without views & 31MB & 65 seconds \\ \hline
			Couchbase with views & 91MB & 65 seconds \\ \hline
		\end{tabular}
		\caption{Couchbase vs SQLite (sources: \cite{LGWSP, LGWST, HW2, PM600, AZW3})}
		\label{tab3}
	\end{center}
\end{table}

Selecting SQL comes with a disadvantage since it does not provide any data synchronization, due to that there must be custom solution created which was already described in \hyperref[sec:Server]{Server} section.

\subsection{TileView}\label{subsec:TileView}
There are multiple ways to display image map in Android, default solutions usually load the whole picture at once. This works for smaller pictures but it does not have to work for bigger ones because the device can run out of memory. To solve this problem it is usually better to try custom library or widget created specifically for displaying such images. One approach is to use 2D or 3D library to display image, these libraries usually work with the image as a whole and implement complex functionality to display it without memory exhaustion. The other approach, also used by Google Maps, is to cut the big image to smaller parts (\verb|tiles|) and display them next to each other. It also makes creating of zoom levels easier for two reasons.

% TODO: Check advantage of tiled maps on the internet
\begin{itemize}
	\item Every zoom level has a collection of images, this makes it easy to keep a good quality for zoom since images are not stretched on the screen as single one would be to maintain the same level of zoom.
	\item When zoomed pictures out of the screen do not have to be kept in memory, this cannot be one with single picture.
\end{itemize}

% TODO: Example of this and how to do it

\section{Application implementation}\label{sec:ApplicationImplementation}
Implementation of this application is split into two parts, mobile and wear. Both of them have to implement two tasks in order to be able to create fingerprint maps. First, scanner for radio signals which will record Bluetooth Low Energy beacons, WiFi access-points and Cellular towers. Second, communication between both implementation, mobile and wear, to allow sending fingerprint information between them. Those are two core functions for both applications but since the synchronization server is used, mobile part also has to communicate with the server.

Both of these applications are programmed in Java language using Android Studio, each of them has a separate configuration and is aimed to different system versions.

\subsection{Scanner}\label{subsec:Scanner}
Scans for radio signal and creates a fingerprint with specific position, device and selected sensor information. This additional data, especially about the device, will help with analysis by splitting data into groups.

There are multiple parts to this task and most of them are very computational heavy so it is better to implement it in a separate \verb|Thread| to prevent application from freezing. Android provides multiple solutions for running tasks in separate Threads.

\begin{itemize}
	\item AsyncTask - Simple solution mainly focused on short running tasks. This implementation is easily created since it handles basic functions like running task, run code before and after task, publish progress to the main Thread and many more.
	\item Service - Mainly focused on long running tasks and it is run immediately after it is started.
	\item Custom Thread - One of the hardest solutions because developer has to handle all the task related to Threads life-cycle and be careful to prevent creation of multiple unwanted Threads.
	\item JobScheduler - One of the newest implementations, it is focused to schedule task and run them when the device has required resources ready and not immediately.
\end{itemize}

Scanner is run using JobScheduler, it is a new technology and Android wants to develop this feature. Handling scanned data is implemented using publish-subscribe design pattern handled by \verb|BroadcastReceiver|. There are three separate Receivers for each type of signal collected and one more for collecting data from sensors. 

\subsubsection{JobScheduler}\label{subsubsec:JobScheduler}
This feature was introduced in Android 5.0 and it remains under active development with major changes in Android version 7.0. This platform collects information about jobs that need to run across all the applications. Some information collected about specific jobs are: required network access, is the job periodic, should the job be scheduled after device restart and more. This information is used to schedule jobs to run at, or around, the time they were scheduled. JobScheduler is intelligent about running jobs and it uses so called batching, which is combining multiple jobs to reduce battery consumption \cite{AD, SOTAJS}.

\begin{lstlisting}[caption=Schedule Firngerprint scanner job.]
// Building job to run
JobInfo.Builder jobBuilder = new JobInfo.Builder(FingerprintScanner.JOB_ID, new ComponentName(getPackageName(), FingerprintScanner.class.getName()));
jobBuilder.setOverrideDeadline(1000);
jobBuilder.setPersisted(false);
jobBuilder.setExtras(bundle);
// Run created job
JobScheduler jobScheduler = (JobScheduler) getSystemService( Context.JOB_SCHEDULER_SERVICE );
jobScheduler.schedule(jobBuilder.build());
\end{lstlisting}

This code is used to schedule Fingerprint scanner. Firstly, a job has to be created with specific ID and class to contain job code. Secondly, job information are provided: this task should start around a second after scheduling, it is not run after device restart and there are custom data send to it via \verb|setExtras()| function. Finally, job scheduler is loaded and this job is run. One thing to remember is to not create a new instance of JobScheduler class since it is a system service.

\subsubsection{BroadcastReceiver}\label{subsubsec:BroadcastReceiver}
Broadcast messages are send from Android system and other Android applications, similar to the publish-subscribe design pattern. This messages are send when an event occurs such as system boot up, start of device charging or network connectivity change. In addition to system events, custom ones can be created in the application to inform other applications. When a broadcast is sent, the system automatically routes it to application that have subscribed to receive that particular type of broadcast \cite{AD}. Following code illustrates how easy is to send a custom broadcast identified by specific action, which can be system or custom. BLE beacon data is added to be received and parse into Fingerprint. Last line sends the actual broadcast to be received by other applications.

\begin{lstlisting}[caption=Send broadcast with BLE beacons found.]
Intent intent = new Intent();
intent.setAction(ACTION_BEACONS_FOUND);
intent.putParcelableArrayListExtra(ACTION_BEACONS_DATA, foundBeacons);
sendBroadcast(intent);
\end{lstlisting}

Receiving broadcasts in application has two steps. First, register the receiver implementation and specific broadcast message it should receive, this can be done via manifest or dynamically in code. If receiver is registered using manifest, application is launched (if it is not running already) when the broadcast is sent. Second, create an implementation of BroadcastReceiver class that will handle information and data using \verb|onReceive()| function.

There are two BroadcastReceiver used in the Scanner. First, used for WiFi scanning since it is a default Android solution. Second, BLE scanner was modified to use this approach because there are multiple parts of this application that can receive information about found beacons. Other two scanners use Listeners which are interfaces handling communication between system and application.

\subsection{Device communication}\label{subsec:DeviceCommunication}
In this application device communication is used to send fingerprint data between devices using Bluetooth. Mobile application sends information about the fingerprints such as location and scan duration, these values are same for both devices. Wear application will in return send result data after scan was finished to save it into the mobile database.

First implementation of this feature was build upon Bluetooth chat example application from Google. This implementation was using three separate Thread to make connection, authorize it and then to send the data when device was connected. Both devices had to accept the connection to send the data, which is normal, but there were some connection loss issues where one devices was considered connected and sending data while the second device was disconnected and not receiving data. That is why this solution was removed at early development stages and substituted by Google's Data Layer API.

To limit data consumption of this application on wear it does not run constantly. Before any scan is started mobile informs wear to start the application, after this is done mobile sends fingerprint data to wear part of the application.

% Example of this as a picture.

\subsubsection{Data Layer API}\label{subsec:DataLayerAPI}
Data Layer is commonly used by Google to send data between their applications, they even have an implementation that gets the data from this layer and sends them to specified applications. This feature is called Google Tag manager and is most commonly used with website applications to send data from the web to Google Analytics.

In Android it has two parts. First, a service that runs when the application is not started to allow passing received data to the application. Second, any activity can implement and Interface that will get received data to process.

\subsection{Server communication}\label{subsec:ServerCommunication}
As it was already mentioned this part is implemented only on mobile part, even though in a new version of Android Wear OS it could be done by both devices. It is not implemented on wear for one simple reason: to lower power consumption. 


%\subsection{Mobile application}\label{subsec:MobileApplication}
%\subsubsection{Activities}\label{subsec:Activities}
%Activities are visible screens of the application. They serve as the entry point for a user's interaction with an application, and are also central to how a user navigates within an application (as with the Back button) or between apps (as with the Recents button) \cite{AD}.

%Main activity for this application is called \verb|ScanActivity|. It displays map with proper building, floor and found Fingerprint in that specific location. It enables users to scan for new beacons and thus create new Fingerprints. Map and controls are implemented using TileView widget that was described in previous section. 

%\subsubsection{Model}\label{subsec:Model}
%Model package contains most important classes of the application and it's split into four parts called: adapters, configuration, database and tasks.

%\paragraph{Adapters}\label{subsec:Adapters}\mbox{} \\
%Adapters information. 

%\paragraph{Configuration}\label{subsec:Configuration}\mbox{} \\
%Configuration classes contain settings of the application. It uses Android's shared preferences that are key-value (xml) files to save small amount of application data. Each SharedPreferences file is managed by the framework and can be private or shared. One thing to note is that these files are not encrypted so it is not good to save user sensitive data in them.

%\paragraph{Database}\label{subsec:Database}\mbox{} \\
%Database package contains all classes needed for communication between application and SQL database. First part of this package are Fingerprints classes that correspond with tables and columns of the database. Second part are so called database helpers that handle communication between the application and SQLite database such as tables creation, selects, inserts, updates and deletions.

%\paragraph{Tasks}\label{subsec:Tasks}\mbox{} \\
%Tasks contain the most complex classes of this application and that is the Fingerprint scanner that has multiple sub-classes to parse all the necessary data from the scan. Tasks also contain connection with the server for data synchronization and Fingerprint transfers.

%\subsubsection{Utilities}\label{subsec:Utilities}
%Utilities contain classes not fit to any other category or classified as support ones which usually means classes for animations or warning messages but since this application communicates with the wear device this package also contains classes that handle such communication.

%\subsection{Wear application}\label{subsec:WearApplication}
%Wear application is simplified version of its smartphone counterpart. It handles only scanning, display of scanning progress and sending the data to the phone. 